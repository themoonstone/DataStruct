## 1. 实现二叉树基本结构
1. 二叉树的基本结构是节点
2. 每个节点包含左子节点和右子节点
3. 添加size确定大小
4. 添加非空判断函数
## 2. 采用递归的方式向二叉树中添加节点
1. 正常情况下，要向一个二分搜索树中插入元素，需要将该元素与左子节点以及右子节点进行比较，确定期插入范围
2. 此时采用递归的方式进行处理
    1. 首先检查当前二叉树是否为空，如果为空，则插入的元素值直接作为其根节点的元素值
    2. 如果不为空，采用递归调用
    3. 根据前面所讲，首先检查递归终止条件
        1. 插入元素与当前二叉树中的某个元素相等，终止
        2. 插入元素小于当前根节点且该节点左子节点为空
        3. 插入元素大于当前根节点且该节点右子节点为空
    4. 终止条件判断完成之后，即可进行递归调用    
## 3. 优化插入代码
1. 目前为止，整个代码逻辑不够统一，实际上，在插入的时候，只要是node为空的条件，就一定要创建一个新的节点
2. 所以可以直接判断空节点，然后进行插入
## 4. 实现二分搜索树查询
1. 检查是否包含了某个元素(递归的方式)
    1. 递归终止条件：元素相等时返回或者查找到node为空时还没找到也返回
    2. 缩减规模：不满足相等条件时
        1. 如果小于当前比较节点，与其左子节点为根节点的子树进行比较
        2. 如果大于当前比较节点，与其右子节点为根节点的子树进行比较
## 5. 二分搜索树前序遍历
1. 前序遍历：先访问节点本身、再访问左右子节点
2. 采用递归进行前序遍历
3. 测试
## 6. 打印输出实现
1. 实现二叉树打印函数        
## 7. 二叉树中序遍历
1. 中序遍历：先遍历左子节点，再遍历根节点，最后遍历右子节点
## 8. 二叉树后序遍历
1. 后序遍历：先遍历左子节点，再遍历右子节点，最后遍历根节点
2. 后序遍历典型应用：二分搜索树的内存释放
## 9. 实现二分搜索树非递归前序遍历
1. 添加栈结构进行辅助，拿到一个节点，压入栈中，在访问节点的时候让节点出栈
2. 访问栈，如果栈不为空，则拿到节点，同时将该节点的子节点压入栈中(鉴于栈的后进先出，先压入右子节点，再压入左子节点)
## 10. 实现二分搜索树层序遍历(广度优先)
1. 基本思路：先遍历第一层，再遍历第二层的方式
2. 结合队列实现，将要访问的节点放入队列中，然后进行访问的时候让该节点出队，将该节点的左右子节点进行入队
3. 注意：这里很容易和前面的栈使用搞混，需要弄清楚栈的先进后出与队列的先进先出的特点
4. 和深度优先遍历相比，广度优先遍历通常能够更快的找到问题的解，因为深度优先会一次跑到底，所以一般来说，广度优先很多时候用于算法设计中的最短路径计算
## 11. 删除二分搜索树中的最小值和最大值
1. 要删除某个节点，首先要找到该节点
2. 对于二分搜索树来说，找到最小节点和最大节点其实非常简单
3. 首先确保该二分搜索树中有节点，也就是说size不能为0
4. 从根节点开始，一直向左走，直到找不到左节点了，就是最小节点
5. 从根节点开始，一直向右走，直到找不到右节点了，就是最大节点
## 12. 删除二分搜索树中的任意节点
1. 删除二分搜索树中的任意节点相对前面删除最大和最小节点来说要复杂一些，应该分情况考虑，具体如下
    1. 要删除的节点只有左子树或者右子树，直接用其左子树根节点或者右子树根节点取代要删除节点的位置
    2. 要删除的节点既有左子树，又有右子树，该情况下，采用如下方式：
        1. 先找一个待删除节点的后继节点(待删除节点的右子树的最小节点，也是离待删除节点最近的节点)
        2. 从待删除节点的右子树上删除该节点(前面实现的删除最小节点)
        3. 用后继节点替换待删除节点
        4. 令待删除节点的左子树变成该后继节点的左子树，完成删除
        5. 删除当前节点
## 13. 查找指定元素在二分搜索树中floor与ceil
1. floor：比指定元素小的最大的元素
   1. floor与前驱节点的主要区别在于floor不一定在我们的二分搜索树里面，而前驱节点一定包含在二分搜索树中,但如果指定元素存在于二分搜索树中，那么这个元素的floor就是其本身
   2. 具体思路如下
    1. 设要查询的元素为节点FN
    2. 如果FN的值小于当前node的值，那么FN的floor节点一定在当前node节点的左子树中
    3. 如果FN的值大于当前node的值，那么node的值可能是FN的floor节点，但也可能不是
        1. 需要和当前node的右子树进行比较
            1. 如果FN小于右子节点，分以下情况
                1. 该右子节点没有左子树，则node就是FN的floor节点
                2. 该右子节点有左子树，但其左子节点比FN要大，则node就是FN的floor节点
                3. 该右子节点有左子树，且其左子节点比FN小，此时该左子节点的值一定会大于node，所以应该传入以node的右子节点为根的新的二叉树，也就是缩减规模
            2. 如果FN大于右子节点，则以右子节点为根的二叉树进行传递，缩减规模   
2. ceil：比指定元素大的最小的元素
    1. ceil查找与floor查找思路类似
        1. 设要查询的元素为节点FN
        2. 如果FN大于当前节点的值，则FN与当前节点的右子树再进行比较
            1. 如果右子树为空，则说明找不到FN的ceil节点
            2. 如果右子树不为空
                1. FN>右子节点的值，继续找右子节点的右子树
                2. FN<右子节点的值，则进行第2大步
        2. 如果FN的节点小于当前node的值，node的值可能是FN的ceil节点，但也可能不是
            1. 需要用FN和当前节点的左子树进行比较。如果当前节点没有左子树，则当前node就是FN的ceil
            2. 如果当前左子节点的值大于FN，则需要继续向后面的左子树比较，同样采用递归的方式
            3. 如果FN大于当前节点左子节点，则需要将FN与当前节点的左子节点的右子树进行比较
                1. 如果没有右子树，则当前node就是FN的ceil
                2. 如果右子节点的值小于FN，则当前node就是FN的ceil
                3. 如果右子节点的值大于FN，则继续以当前节点的左子节点为根的二分搜索树进行查找
## 14. 关于二分搜索树的floor与ceil的优化
前面花了很大的精力去做一条一条的条件对比，但实际上不用这么复杂，可以用更简洁的方法实现
1. floor(查找小于指定元素E(FN)的最大值)
    1. 首先我们知道，从根节点开始查询需要先对根节点root与FN大小进行比较，后面则不断的与相应的节点进行递归比较
        1. FN小于node.element，则node以及其右子树节点的值都比FN要大，所以只能从左子树上查找
        2. FN大于node.element，这里有两种情况
            1. 当前node就是FN的floor节点，直接递归调用查询左子树即可
            2. 当前node不是FN的floor节点，因为node的右子树的节点都都比node大，所以可能FN的floor节点在node右子树中，所以需要先递归调用右子树查询，如果找不到，则说明当前node就是FN的floor节点
## 15. 查找指定元素在二分搜索树中rank与select
1. rank：查找指定元素在二分搜索树中排名第几
2. select：查找在二分搜索树中排名第10的元素是多少