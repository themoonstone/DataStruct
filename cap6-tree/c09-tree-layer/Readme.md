## 1. 实现二叉树基本结构
1. 二叉树的基本结构是节点
2. 每个节点包含左子节点和右子节点
3. 添加size确定大小
4. 添加非空判断函数
## 2. 采用递归的方式向二叉树中添加节点
1. 正常情况下，要向一个二分搜索树中插入元素，需要将该元素与左子节点以及右子节点进行比较，确定期插入范围
2. 此时采用递归的方式进行处理
    1. 首先检查当前二叉树是否为空，如果为空，则插入的元素值直接作为其根节点的元素值
    2. 如果不为空，采用递归调用
    3. 根据前面所讲，首先检查递归终止条件
        1. 插入元素与当前二叉树中的某个元素相等，终止
        2. 插入元素小于当前根节点且该节点左子节点为空
        3. 插入元素大于当前根节点且该节点右子节点为空
    4. 终止条件判断完成之后，即可进行递归调用    
## 3. 优化插入代码
1. 目前为止，整个代码逻辑不够统一，实际上，在插入的时候，只要是node为空的条件，就一定要创建一个新的节点
2. 所以可以直接判断空节点，然后进行插入
## 4. 实现二分搜索树查询
1. 检查是否包含了某个元素(递归的方式)
    1. 递归终止条件：元素相等时返回或者查找到node为空时还没找到也返回
    2. 缩减规模：不满足相等条件时
        1. 如果小于当前比较节点，与其左子节点为根节点的子树进行比较
        2. 如果大于当前比较节点，与其右子节点为根节点的子树进行比较
## 5. 二分搜索树前序遍历
1. 前序遍历：先访问节点本身、再访问左右子节点
2. 采用递归进行前序遍历
3. 测试
## 6. 打印输出实现
1. 实现二叉树打印函数        
## 7. 二叉树中序遍历
1. 中序遍历：先遍历左子节点，再遍历根节点，最后遍历右子节点
## 8. 二叉树后序遍历
1. 后序遍历：先遍历左子节点，再遍历右子节点，最后遍历根节点
2. 后序遍历典型应用：二分搜索树的内存释放
## 9. 实现二分搜索树非递归前序遍历
1. 添加栈结构进行辅助，拿到一个节点，压入栈中，在访问节点的时候让节点出栈
2. 访问栈，如果栈不为空，则拿到节点，同时将该节点的子节点压入栈中(鉴于栈的后进先出，先压入右子节点，再压入左子节点)
## 10. 实现二分搜索树层序遍历(广度优先)
1. 基本思路：先遍历第一层，再遍历第二层的方式
2. 结合队列实现，将要访问的节点放入队列中，然后进行访问的时候让该节点出队，将该节点的左右子节点进行入队
3. 注意：这里很容易和前面的栈使用搞混，需要弄清楚栈的先进后出与队列的先进先出的特点
4. 和深度优先遍历相比，广度优先遍历通常能够更快的找到问题的解，因为深度优先会一次跑到底，所以一般来说，广度优先很多时候用于算法设计中的最短路径计算
