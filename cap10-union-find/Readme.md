## 并查集
### 基本概念
- 主要作用:查询两个元素是否属于同一个集合中。比如两个节点是否位于同一个网络、两个微信好友是否有同一个朋友圈
- 主要方法:
    - isConnected(p, q):两个元素是否属于同一个集合
    - unionElement(q, p):合并两个元素到同一个集合中
### 实现array模拟并查集(quick find)
- 基本思路:通过给定大小的数组存储元素对应的集合、
- 查找:检查p, q的索引是否相同、时间复杂度O(1)
- 合并:遍历数组、将p以及与p相同的集合改为q的集合、也可以反过来O(n)
### 实现真正的并查集(quick union)
- 基本思路:给定一个数组parent, parent[i]表示第i个元素所在的节点它指向了哪个元素 
- 查找:找到p,q的根节点(根节点自己指向自己)、检查其根节点是否相等
- 合并:找到p, q 的根节点、希望让p的根节点指向q的根节点、也可以反过来
- 时间复杂度: 查找与合并都是O(h), 其中h为树的高度
### 对并查集进行基于size的优化
- 思路2存在的问题:对quick union来说、每次合并p,q都将p指向q、这会导致整个树的高度越来越大、所以可以进行一定的优化
- 添加一个sz数组、维护每一个元素i、sz[i]表示在以i为根的集合中的元素个数
- 在合并的时候先找到p,q的根节点、然后对两个根节点下的元素个数进行判断, 让元素个数少的根节点指向元素个数大的根节点
- 通过上面的方式、有比较大的概率让整个树的深度不会增加、也就是尽量保证并查集的树的深度是最小的
### 对并查集进行基于rank的优化
- 思路3存在的总是:以元素个数为判断标准进行比较、不能完全实现每次都找到高度最小的树、因为会存在元素个数更多、但高度更小的情况
- 维护一个rank数组、rank[i]表示以i为根的集合树的深度
- 比较方法同上
- 区别:维护rank数组、在p,q相等的时候、不管向哪一方合并、rank深度是一定会加1的、所以需要注意、这里需要对p==q的情况进行单独判断
### 路径压缩
- 在执行find的时候、可以进行路径压缩、从而进一步的降低并查集树的高度
- 区别:这里的rank不再表示并查集的深度、而是表示排名、因为在find的时候、rank实际上是有变化的、但仍然可以保证rank大的节点在上面、rank小的节点在下面
### 路径压缩优化
- 将整个并查集的树深度压缩为2
- 在find的时候采用递归的方式
- 需要注意的是、这里虽然能够压缩、但因为采用了递归调用的方式、所以时间复杂度反而要差一点
### 并查集时间复杂度分析
- 实际上、并查集的时间复杂度是O(log*n)的级别、它比O(logn)还要快、近乎是O(1)的级别